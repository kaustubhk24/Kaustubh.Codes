"use strict";(self.webpackChunkkaustubh=self.webpackChunkkaustubh||[]).push([[82789],{3905:(n,e,r)=>{r.d(e,{Zo:()=>m,kt:()=>d});var t=r(67294);function s(n,e,r){return e in n?Object.defineProperty(n,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):n[e]=r,n}function a(n,e){var r=Object.keys(n);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(n);e&&(t=t.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),r.push.apply(r,t)}return r}function i(n){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?a(Object(r),!0).forEach((function(e){s(n,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(r,e))}))}return n}function p(n,e){if(null==n)return{};var r,t,s=function(n,e){if(null==n)return{};var r,t,s={},a=Object.keys(n);for(t=0;t<a.length;t++)r=a[t],e.indexOf(r)>=0||(s[r]=n[r]);return s}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(t=0;t<a.length;t++)r=a[t],e.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(n,r)&&(s[r]=n[r])}return s}var o=t.createContext({}),u=function(n){var e=t.useContext(o),r=e;return n&&(r="function"==typeof n?n(e):i(i({},e),n)),r},m=function(n){var e=u(n.components);return t.createElement(o.Provider,{value:e},n.children)},c="mdxType",l={inlineCode:"code",wrapper:function(n){var e=n.children;return t.createElement(t.Fragment,{},e)}},f=t.forwardRef((function(n,e){var r=n.components,s=n.mdxType,a=n.originalType,o=n.parentName,m=p(n,["components","mdxType","originalType","parentName"]),c=u(r),f=s,d=c["".concat(o,".").concat(f)]||c[f]||l[f]||a;return r?t.createElement(d,i(i({ref:e},m),{},{components:r})):t.createElement(d,i({ref:e},m))}));function d(n,e){var r=arguments,s=e&&e.mdxType;if("string"==typeof n||s){var a=r.length,i=new Array(a);i[0]=f;var p={};for(var o in e)hasOwnProperty.call(e,o)&&(p[o]=e[o]);p.originalType=n,p[c]="string"==typeof n?n:s,i[1]=p;for(var u=2;u<a;u++)i[u]=r[u];return t.createElement.apply(null,i)}return t.createElement.apply(null,r)}f.displayName="MDXCreateElement"},16744:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>o,contentTitle:()=>i,default:()=>l,frontMatter:()=>a,metadata:()=>p,toc:()=>u});var t=r(87462),s=(r(67294),r(3905));const a={title:"Program for Sparse Matrix in CPP",date:new Date("2020-08-16T12:13:00.000Z"),authors:"kaustubh",slug:"/program-for-sparse-matrix-in-cpp/"},i=void 0,p={permalink:"/blog/program-for-sparse-matrix-in-cpp/",source:"@site/blog/2020-08-16-program-for-sparse-matrix-in-cpp.md",title:"Program for Sparse Matrix in CPP",description:"",date:"2020-08-16T12:13:00.000Z",formattedDate:"August 16, 2020",tags:[],readingTime:.91,hasTruncateMarker:!1,authors:[{name:"Kaustubh Kulkarni",title:"ServiceNow Developer",url:"https://github.com/kaustubhk24",imageURL:"https://www.gravatar.com/avatar/b76fcfc82fc2e8fdc8075636f1735f61?s=200",key:"kaustubh"}],frontMatter:{title:"Program for Sparse Matrix in CPP",date:"2020-08-16T12:13:00.000Z",authors:"kaustubh",slug:"/program-for-sparse-matrix-in-cpp/"},prevItem:{title:"Program for Stack Implementation using CPP",permalink:"/blog/program-for-stack-implementation-using-cpp/"},nextItem:{title:"Program for Addition of Polynomial in CPP",permalink:"/blog/program-for-addition-of-polynomial-in-cpp/"}},o={authorsImageUrls:[void 0]},u=[],m={toc:u},c="wrapper";function l(n){let{components:e,...r}=n;return(0,s.kt)(c,(0,t.Z)({},m,r,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp",metastring:'title="Sparse.cpp"',title:'"Sparse.cpp"'},'  \n#include  \nusing namespace std;   \nint main()  \n{  \n int sparse1[10][3],sparse2[10][3],sum[10][3];  \n int m,n,p,q,t1,t2,s,d,element;  \n int i,j;  \n cout<<"Enter the number of rows and columns:";  \n cin>>m>>n;  \n t1=t2=0;  \n cout<<"Enter the first matrix:n";  \n for(i=1;i<=m;i++)  \n {  \n for(j=1;j<=n;j++)  \n {  \n cin>>element;  \n if(element!=0)  \n {  \n t1=t1+1;  \n sparse1[t1][1]=i;  \n sparse1[t1][2]=j;  \n sparse1[t1][3]=element;  \n }  \n }  \n }  \n sparse1[0][1]=m;  \n sparse1[0][2]=n;  \n sparse1[0][3]=t1;  \n cout<<"Enter the second matrix:n";  \n for(i=1;i<=m;i++)  \n {  \n for(j=1;j<=n;j++)  \n {  \n cin>>element;  \n if(element!=0)  \n {  \n t2=t2+1;  \n sparse2[t2][1]=i;  \n sparse2[t2][2]=j;  \n sparse2[t2][3]=element;  \n }  \n }  \n }  \n sparse2[0][1]=m;  \n sparse2[0][2]=n;  \n sparse2[0][3]=t2;  \n cout<<"The first sparse matrix is:";  \n cout<<"n-----------------------n";  \n for(i=0;i<=t1;i++)  \n {  \n cout< }  \n cout<<"The second sparse matrix is:";  \n cout<<"n-----------------------n";  \n for(i=0;i<=t2;i++)  \n {  \n cout< }  \n i=j=s=d=1;  \n while((i<=t1)&&(j<=t2))  \n {  \n if(sparse1[i][1]==sparse2[j][1])   \n {  \n if(sparse1[i][2]==sparse2[j][2])   \n {  \n sum[s][1]=sparse1[i][1];  \n sum[s][2]=sparse1[i][2];  \n sum[s][3]=sparse1[i][3]+sparse2[j][3];  \n i++;  \n j++;  \n if(sum[s][3]!=0)  \n s++;  \n }  \n else   \n {  \n if(sparse1[i][2] {  \n sum[s][1]=sparse1[i][1];  \n sum[s][2]=sparse1[i][2];  \n sum[s][3]=sparse1[i][3];  \n i++;  \n s++;  \n d++;  \n }  \n else  \n {  \n sum[s][1]=sparse2[j][1];  \n sum[s][2]=sparse2[j][2];  \n sum[s][3]=sparse2[j][3];  \n j++;  \n d++;  \n s++;  \n }  \n }  \n }  \n else   \n {  \n if(sparse1[i][1] {  \n sum[s][1]=sparse1[i][1];  \n sum[s][2]=sparse1[i][2];  \n sum[s][3]=sparse1[i][3];  \n i++;  \n d++;  \n s++;  \n }  \n else  \n {  \n sum[s][1]=sparse2[j][1];  \n sum[s][2]=sparse2[j][2];  \n sum[s][3]=sparse2[j][3];  \n j++;  \n s++;  \n d++;  \n }  \n }  \n }  \n if(i<=t1)  \n {  \n for(p=i;p<=t1;p++)  \n {  \n sum[s][1]=sparse1[p][1];  \n sum[s][2]=sparse1[p][2];  \n sum[s][3]=sparse1[p][3];  \n s++;  \n d++;  \n }  \n }  \n else if(j<=t2)  \n {  \n for(p=j;p<=t2;p++)  \n {  \n sum[s][1]=sparse2[p][1];  \n sum[s][2]=sparse2[p][2];  \n sum[s][3]=sparse2[p][3];  \n s++;  \n d++;  \n }  \n }  \n sum[0][1]=m,sum[0][2]=n,sum[0][3]=s-1;  \n cout<<"The sum is :";  \n cout<<"n-----------------------n";  \n for(i=0;i {  \n cout< }  \n return 0;  \n}  \n  \n  \n\n')))}l.isMDXComponent=!0}}]);